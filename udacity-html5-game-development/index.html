
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Udacity - HTML5 Game Development - Caroline Aubry</title>
  <meta name="author" content="Caroline Aubry">

  
  <meta name="description" content="Hey all &amp; Happy New Year! A decision has been made&hellip; it&rsquo;s time for me to start on a new course related to Game Development.
Last year &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://caubry.github.io/udacity-html5-game-development">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Caroline Aubry" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="header-inner">
    <span class="first"><a href="/">Caroline Aubry</a></span>
    <span><a href="/about">about</a></span>
    <span><a href="/projects">projects</a></span>
    <span class="last"><a href="/atom.xml" title="subscribe via RSS">rss</a></span>
  </div>
</hgroup>
</header>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Udacity - HTML5 Game Development</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-15T13:17:14+00:00" pubdate data-updated="true">Jan 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Hey all &amp; Happy New Year!</p>

<p>A decision has been made&hellip; it&rsquo;s time for me to start on a new course related to Game Development.<br/>
Last year, I took a few online courses on <a href="https://www.coursera.org/course/startup/">Coursera</a> and I loved them : ]<br/>
For those you do not know Coursera yet, it is a website that offers plenty of free courses on diverse topics. It is fun and you have to be really rigorous to pass your certificates : D<br/>
The courses that I undertook were:</p>

<ul>
<li><a href="https://www.coursera.org/course/startup/">Startup Engineering</a> &ndash; Stanford University;</li>
<li><a href="https://www.coursera.org/course/digitalmedia/">Creative Programming for Digital Media &amp; Mobile Apps</a> &ndash; University of London International Programmes</li>
<li><a href="https://www.coursera.org/course/cpp-fr/">Introduction à la Programmation Orientée Objet (en C++)</a> &ndash; Ecole Polytechnique Fédérale de Lausanne (but didn’t have any spare time to finish this course.)</li>
</ul>


<p>Anyway, now it&rsquo;s time to try on a new course&hellip; <a href="https://www.udacity.com/course/cs255/">HTML5 Game Development</a> offered by <a href="https://www.udacity.com/">Udacity</a>.<br/>
I thought it might be a good idea to keep a track on what I&rsquo;m actually learning : ]<br/>
I hope you will enjoy reading about it &amp; try this course out for yourself!</p>

<h3>Contents</h3>

<h4>Basics</h4>

<p><a href="#a0">Run-time and parse-time functions</a><br/>
<a href="#a1">Inspecting JSON</a><br/>
<a href="#a2">XMLHttpRequest</a><br/>
<a href="#a3">Loading Sound with XMLHttpRequest</a><br/>
<a href="#a4">Abstracting XMLHttpRequests</a><br/>
<a href="#a5">Interfacing the DOM</a><br/>
<a href="#a6">Prototype</a><br/>
<a href="#a7">Classes</a></p>

<h4>Canvas</h4>

<p><a href="#b0">Canvas</a><br/>
<a href="#b1">Loading Images</a><br/>
<a href="#b2">Drawing Images</a><br/>
<a href="#b3">Animation</a></p>

<h4>Atlases</h4>

<p><a href="#c0">Atlases</a><br/>
<a href="#c1">Parsing texture packer output</a><br/>
<a href="#c2">Rendering texture packer output</a><br/>
<a href="#c3">Parsing Trimmed Textures</a><br/>
<a href="#c4">Tiled</a><br/>
<a href="#c5">Loading Map Data</a><br/>
<a href="#c6">Drawing Tiles</a></p>

<h4>Input</h4>

<p><a href="#d0">Event Listening</a><br/>
<a href="#d1">Keyboard Input Manager</a><br/>
<a href="#d2">Keymapped Input</a><br/>
<a href="#d3">Physics Engine API</a><br/>
<a href="#d4">Mouse/Keyboard Firing</a></p>

<h4>Physics</h4>

<p><a href="#e0">AABB Collision</a><br/>
<a href="#e1">Box2D</a></p>

<h4>Sounds</h4>

<p><a href="#f0">Sounds</a></p>

<h4>Asset Loading</h4>

<p><a href="#g0">Batches</a></p>

<h3>Conclusion</h3>

<p>I&rsquo;ve learnt HTML5 Game Development &ndash; JavaScript basics such as objects, functions, prototype, canvas and the DOM. Other factors that were studied include animation, rendering TexturePacker output, drawing tiles, working with user input, AABB Collision, Box2D, sounds and batch asset loading.</p>

<h3><a name=a0></a>Run-time and parse-time functions</h3>

<p>This wasn&rsquo;t touched upon in the course, but I think it&rsquo;s important to know the difference between these two ways of declaring a JavaScript function.</p>

<pre><code>// Error
functionOne();

var functionOne = function() {
  //
}

// No error
functionTwo();

function functionTwo() {
  //
}
</code></pre>

<p>The distinction between these two functions is that functionOne is defined at run-time, so not accessible before decoration, whereas functionTwo is defined at parse-time and becomes accessible at anytime.</p>

<h3><a name=a1></a>Inspecting JSON</h3>

<p>Inspecting JSON using the JavaScript method, parse the JSON file:</p>

<pre><code>JSON.parse(text, reviver);
</code></pre>

<ul>
<li>text &ndash; String to parse as JSON;</li>
<li>reviver &ndash; Optional function.</li>
</ul>


<p>In this example, the return value is going to be 110.</p>

<pre><code>JSONExample = {
    "frames": {
        "chaingun_impact.png": {
            "frame": {
                "x":1162,
                "y":322,
                "w":38,
                "h":34
            },
            "rotated": false,
            "trimmed": true,
            "spriteSourceSize": {
                "x":110,
                "y":111,
                "w":38,
                "h":34
            },
            "sourceSize": {
                "w":256,
                "h":256
            }
        }
    }
};
</code></pre>

<p>Parse weaponJSON and assign it to a variable, so you can now access this JSON file as an object.</p>

<pre><code>parseJSON = function (weaponJSON) {
  var object = JSON.parse(weaponJSON);
  console.log(object.frames['chaingun_impact.png'].spriteSourceSize.x);
};
</code></pre>

<h3><a name=a2></a>XMLHttpRequest</h3>

<p>To make a request using the JavaScript object&nbsp;XMLHttpRequest, you first need to instantiate the XMLHttpRequest object using the keyword &lsquo;new&rsquo; and initialise this request with its method:</p>

<pre><code>open(method, URL, async);
</code></pre>

<ul>
<li>method &ndash; GET or POST;</li>
<li>URL &ndash; To send the request to as a String;</li>
<li>async &ndash; Optional boolean, defaulting to true, indicating whether or not to perform the operation asynchronously.</li>
</ul>


<p>The method to use can be &ldquo;GET&rdquo;, &ldquo;POST&rdquo;, &ldquo;PUT&rdquo;, &ldquo;DELETE&rdquo;, etc. The most common ones are GET and POST. However, GET is simpler and faster than POST, and can be used in most cases.<br/>
POST requests can be used when:</p>

<ul>
<li>A cached file is not an option (update a file or database on the server);</li>
<li>Sending a large amount of data to the server (POST has no size limitations);</li>
<li>Sending user input (which can contain unknown characters), POST is more robust and secure than GET.</li>
</ul>


<p>Therefore, you need to assign the parseJSON response to the property onload, and finally send this request out.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>parseJSON = function (weaponJSON) {
</span><span class='line'>    var parsedJSON = JSON.parse(weaponJSON);
</span><span class='line'>    return parsedJSON['frames']['chaingun_impact.png']['spriteSourceSize']['x'];
</span><span class='line'>};
</span><span class='line'> 
</span><span class='line'>var setup = function() {
</span><span class='line'>    var xmlRequest = new XMLHttpRequest();
</span><span class='line'>    xmlRequest.open("GET", "/media/resources/gamedev/weapon.json", true);
</span><span class='line'>    
</span><span class='line'>    xmlRequest.onload  = function () { 
</span><span class='line'>        parseJSON = JSON.parse(this.responseText);
</span><span class='line'>    };
</span><span class='line'>    xmlRequest.send();
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h3><a name=a3></a>Loading Sound with XMLHttpRequest</h3>

<p>Loading a sound involves the same steps as to load a JSON file.<br/>
Firstly, you need to instantiate the XMLHttpRequest object, initialise this request with its method &lsquo;open&rsquo;, assign the parseJSON response to the property onload, and finally send this request out.<br/>
The only difference is that when working with audio, the property responseType on the XMLHttpRequest object has to be set to &lsquo;arrayBuffer&rsquo; as a String.</p>

<pre><code>var setup = function() {
    var soundRequest = new XMLHttpRequest();
    soundRequest.open("GET", "/media/audio/gamedev/bg_menu.ogg", true);
    soundRequest.responseType = "arraybuffer";

    soundRequest.onload = function () {
    try {
       //
    }
    catch(e) {
       console.warn('Web Audio API is not supported in this browser');
    }
   };
   soundRequest.send();
};
</code></pre>

<h3><a name=a4></a>Abstracting XMLHttpRequests</h3>

<p>The function xhrGet takes in the Request uri, a callback function and a type with or without a value.<br/>
ParseJSON function takes the xhr and parse xhr.responseText.<br/>
You can then call the xhrGet function by passing a JSON file, a callback function, such as parseJSON and a type with or without a value.<br/>
Note: If passing a JSON file, the value can be null, whereas when using sounds for instance, the value can be set to &lsquo;arraybuffer&rsquo;.</p>

<pre><code>function xhrGet(reqUri, callback, type) {
    var caller = xhrGet.caller;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", reqUri, true);
    if (type) xhr.responseType = type;

    xhr.onload=function () {
      if (callback) {
        try {
          callback(xhr);
        }
        catch(e) {
          throw 'xhrGet failed:\n' + reqUri + '\nException: ' + e + '\nresponseText: ' + xhr.responseText + '\ncaller: ' + caller;
        }
      }
    };
    xhr.send();
};

parseJSON = function (xhr) {
    var parsedJSON = JSON.parse(xhr.responseText);

    var x = parsedJSON['frames']['chaingun_impact.png']['spriteSourceSize']['x'];
    console.log(x);
    return x;
};

xhrGet('weaponJSON', parseJSON, null);
</code></pre>

<h3><a name=a5></a>Interfacing the DOM</h3>

<p>Firstly, a body DOM object is created, stored in a variable and its id is set to &lsquo;body&rsquo;, by using the document.getElementById method.<br/>
A new div DOM object is created, using the document.createElement method and set its id property to &lsquo;gameContent&rsquo;.<br/>
A new canvas DOM object can now be created, as the div DOM object exists, by using once again the document.createElement method. Its id as to be set to &lsquo;gameCanvas&rsquo;.<br/>
Finally, the canvas DOM object is attached to the div DOM object and the div DOM object to the body, only if no errors have been found while doing so.</p>

<pre><code>var manipulateDOM = function() {
  var body=document.getElementById("body");
  var div=document.createElement("div");

  if(div){
      div.id = "gameContent";
      var canvas=document.createElement("canvas");
      canvas.id = "gameCanvas";

      try {
        body.appendChild(div);
        div.appendChild(canvas);    
      } catch (e){
        document.write(e);
      }
    }
};
manipulateDOM();
</code></pre>

<h3><a name=a6></a>Prototype</h3>

<p>JavaScript provides a way where you can define a set of variables as well as functions encapsulated within an object, called the prototype. When you define a function within JavaScript, it comes with a few pre-defined properties; one of these is the illusive prototype.<br/>
The prototype property is initially an empty object, and can have members added to it &ndash; as you would with any other object.</p>

<pre><code>var myObject = function(name){
  this.name = name;
  return this;
};

console.log(typeof myObject.prototype); // object

myObject.prototype.getName = function(){
  return this.name;
};
</code></pre>

<h3><a name=a7></a>Classes</h3>

<p>JavaScript is a class-free, object-oriented language, and as such, it uses prototypal inheritance instead of classical inheritance.<br/>
Inheritance trees can be built by chaining prototypes to other objects, by using Class.extend method.<br/>
So Weapon extends Class, MachineGun extends Weapon and so on and so forth.</p>

<pre><code>Weapon = Class.extend({
    init: function() {
    }
});

MachineGun = Weapon.extend({
    init: function() {
    }
});

Weapon          = Class.extend({});
MachineGun      = Weapon.extend({});
Entity          = Class.extend({});
ChainGun        = Weapon.extend({});
Teleporter      = Entity.extend({});
EnergyCanister  = Entity.extend({});
</code></pre>

<h3><a name=b0></a>Canvas</h3>

<p>Canvas is a new HTML5 element which exposes APIs allowing you to draw a graph, images and text to portions of the page. Canvas has only two attributes specific to it, width and height.<br/>
In order to insert the canvas to the DOM, the canvas has to be attached to the document, using the appendChild method.</p>

<pre><code>setup = function() {
  var body = document.getElementById("body");
  var canvas = document.createElement("canvas");

  canvas.width = 1200;
  canvas.height = 720;

  body.appendChild(canvas);
};
</code></pre>

<h3><a name=b1></a>Loading Images</h3>

<p>An image has to be preloaded before it can be drawn in the canvas.<br/>
To do so, a new Image() object has to be created. A few steps has to be followed:</p>

<ul>
<li>declare a new Image() object;</li>
<li>define its onload method;</li>
<li>set the Image source attribute.</li>
</ul>


<p>As soon as the source property to this image is set to a value, JavaScript will kick off a load function.<br/>
Because of this, a callback function has to be specified before setting a source attribute, otherwise the image will load the data and no callback will be received.<br/>
The getContext() method returns an object that provides methods and properties for drawing on the canvas.<br/>
This reference will cover the properties and methods of the getContext(&ldquo;2d&rdquo;) object, which can be used to draw text, lines, boxes, circles, and more &ndash; on the canvas.</p>

<pre><code>var img = new Image();

setup = function() {
  var body = document.getElementById('body');
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  body.appendChild(canvas);

  img.onload = onImageLoad;
  img.src    = "/media/img/gamedev/ralphyrobot.png";

  body.appendChild(img);
};

onImageLoad = function(){
  console.log("Image Loaded");
};
</code></pre>

<h3><a name=b2></a>Drawing Images</h3>

<p>The function drawImage() is used in order to draw images on the canvas. This function takes the Image object itself as well as the location of this image on the canvas.</p>

<pre><code>var canvas = null;
var ctx = null;
var img = null;

var onImageLoad = function(){
  console.log("Image Loaded");
  ctx.drawImage(img, 192, 192);
  canvas.appendChild(img);
};

var setup = function() {
  var body = document.getElementById("body");
  canvas = document.createElement("canvas");

  ctx = canvas.getContext('2d');

  canvas.setAttribute('width', 500);
  canvas.setAttribute('height', 700);

  body.appendChild(canvas);
  img = new Image();
  img.onload = onImageLoad;
  img.src = "/media/img/gamedev/ralphyrobot.png";
};
</code></pre>

<h3><a name=b3></a>Animation</h3>

<p>The canvas doesn&rsquo;t clear itself each frame. The clearRect() method clears the specified pixels within a given rectangle, in order to draw back on the canvas.<br/>
The parameters are X, Y, Width and Height as integers;</p>

<pre><code>var canvas = null;
var ctx = null;
var frameRate = 1000/30;
var frame = 0;
var assets = ['/media/img/gamedev/robowalk/robowalk00.png',
              '/media/img/gamedev/robowalk/robowalk01.png',
              '/media/img/gamedev/robowalk/robowalk02.png',
              '/media/img/gamedev/robowalk/robowalk03.png',
              '/media/img/gamedev/robowalk/robowalk04.png',
              '/media/img/gamedev/robowalk/robowalk05.png',
              '/media/img/gamedev/robowalk/robowalk06.png',
              '/media/img/gamedev/robowalk/robowalk07.png',
              '/media/img/gamedev/robowalk/robowalk08.png',
              '/media/img/gamedev/robowalk/robowalk09.png',
              '/media/img/gamedev/robowalk/robowalk10.png',
              '/media/img/gamedev/robowalk/robowalk11.png',
              '/media/img/gamedev/robowalk/robowalk12.png',
              '/media/img/gamedev/robowalk/robowalk13.png',
              '/media/img/gamedev/robowalk/robowalk14.png',
              '/media/img/gamedev/robowalk/robowalk15.png',
              '/media/img/gamedev/robowalk/robowalk16.png',
              '/media/img/gamedev/robowalk/robowalk17.png',
              '/media/img/gamedev/robowalk/robowalk18.png'
             ];
var frames = [];

var onImageLoad = function(){
    console.log("IMAGE!!!");
};

var setup = function() {
    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    for(i = 0; i &lt; assets.length; ++i)
    {
        frames.push(new Image());
        frames[i].onload = onImageLoad;
        frames[i].src = assets[i];
    }
    setInterval(animate, frameRate); 
};

var animate = function(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(frames[frame], 192, 192);
    frame = (frame + 1) % frames.length;  
};

setup();
</code></pre>

<h3><a name=c0></a>Atlases</h3>

<p>A texture atlas is a large image containing a collection of images in order to reduce load time and the number of http requests. Whereas spritesheet is a term reserved for animated objects only.<br/>
<a href="http://www.codeandweb.com/texturepacker">Texture Packer</a> is a great off the shelf tool to generate the atlas data.</p>

<h3><a name=c1></a>Parsing texture packer output</h3>

<p>In the code below, I had to iterate through each sprite in the parsed JSON file and calculate the center (x,y) offsets from the &lsquo;width&rsquo; and &lsquo;height&rsquo; values listed in the JSON.<br/>
And finally, pass the sprite name, the (x,y) coordinates, the width and height, and the center (x,y) offsets calculated to the above &lsquo;defSprite&rsquo; method of &lsquo;SpriteSheetClass&rsquo;.</p>

<pre><code>var gSpriteSheets = {};

SpriteSheetClass = Class.extend({

    img: null,

    url: "",

    sprites: new Array(),

    init: function () {},

    load: function (imgName) {
        this.url = imgName;

    var img = new Image();
    img.src = imgName;
    this.img = img;

    gSpriteSheets[imgName] = this;
    },

    defSprite: function (name, x, y, w, h, cx, cy) {
       var spt = {
        "id": name,
        "x": x,
        "y": y,
        "w": w,
        "h": h,
        "cx": cx == null ? 0 : cx,
        "cy": cy == null ? 0 : cy
    };

    this.sprites.push(spt);
    },

        parseAtlasDefinition: function (atlasJSON) {
        var parsedJSON = JSON.parse(atlasJSON);

        for (var key in parsedJSON.frames) {
           var sprite = parsedJSON.frames[key];
           var cx = -sprite.frame.w*0.5;
           var cy = -sprite.frame.h*0.5;
           this.defSprite(key, sprite.frame.x, sprite.frame.y, sprite.frame.w, sprite.frame.h, cx, cy);
      }   
    }
});
</code></pre>

<h3><a name=c2></a>Rendering texture packer output</h3>

<pre><code>var gSpriteSheets = {};

SpriteSheetClass = Class.extend({

    img: null,

    url: "",

    sprites: [],

    init: function () {},

    load: function (imgName) {
    this.url = imgName;
        var img = new Image();
        img.src = imgName;
        this.img = img;
        gSpriteSheets[imgName] = this;
    },

    defSprite: function (name, x, y, w, h, cx, cy) {
        var spt = {
            "id": name,
            "x": x,
            "y": y,
            "w": w,
            "h": h,
            "cx": cx === null ? 0 : cx,
            "cy": cy === null ? 0 : cy
        };

        this.sprites.push(spt);
    },

    parseAtlasDefinition: function (atlasJSON) {
    var parsed = JSON.parse(atlasJSON);

        for(var key in parsed.frames) {
            var sprite = parsed.frames[key];

            var cx = -sprite.frame.w * 0.5;
            var cy = -sprite.frame.h * 0.5;

            this.defSprite(key, sprite.frame.x, sprite.frame.y, sprite.frame.w, sprite.frame.h, cx, cy);
        }
    },

    getStats: function (name) {
        for(var i = 0; i &lt; this.sprites.length; i++) {
            if(this.sprites[i].id === name) {
                return this.sprites[i];
            }

        }
        return null;
    }
});

function drawSprite(spritename, posX, posY) {
    for (var i in gSpriteSheets){
        var act = gSpriteSheets[i].getStats(spritename);
        if (act !== null){
            __drawSpriteInternal(act, gSpriteSheets[i], posX,posY);
        }
    }
}

function __drawSpriteInternal(spt, sheet, posX, posY) {

    if (sheet === null || spt === null){
        return;
    }
    ctx.drawImage(sheet.img, spt.x, spt.y, spt.w, spt.h, posX + spt.cx, posY + spt.cy, spt.w, spt.h);
}
</code></pre>

<h3><a name=c3></a>Parsing Trimmed Textures</h3>

<pre><code>var gSpriteSheets = {};

SpriteSheetClass = Class.extend({
    img: null,

    url: "",

    sprites: [],

    init: function () {},

    load: function (imgName) {
        this.url = imgName;
        var img = new Image();
        img.src = imgName;
        this.img = img;
        gSpriteSheets[imgName] = this;
    },

    defSprite: function (name, x, y, w, h, cx, cy) {
        var spt = {
            "id": name,
            "x": x,
            "y": y,
            "w": w,
            "h": h,
            "cx": cx === null ? 0 : cx,
            "cy": cy === null ? 0 : cy
        };
        this.sprites.push(spt);
    },

    parseAtlasDefinition: function (atlasJSON) {
      var parsed = JSON.parse(atlasJSON);

          for(var key in parsed.frames) {
              var sprite = parsed.frames[key];
            var cx = -sprite.frame.w * 0.5;
            var cy = -sprite.frame.h * 0.5;

        if (sprite.trimmed) {
            cx = sprite.spriteSourceSize.x - sprite.sourceSize.w * 0.5;
            cy = sprite.spriteSourceSize.y - sprite.sourceSize.h * 0.5;
        }

            this.defSprite(key, sprite.frame.x, sprite.frame.y, sprite.frame.w, sprite.frame.h, cx, cy);
        }
    },

    getStats: function (name) {
        for(var i = 0; i &lt; this.sprites.length; i++) {
        if(this.sprites[i].id === name) {
          return this.sprites[i];
        }
        }
        return null;
    }

});

function drawSprite(spritename, posX, posY) {
      for(var sheetName in gSpriteSheets) {
        var sheet = gSpriteSheets[sheetName];
        var sprite = sheet.getStats(spritename);

      if(sprite === null) {
         continue;
      }
        __drawSpriteInternal(sprite, sheet, posX, posY);
        return;
      }
}

function __drawSpriteInternal(spt, sheet, posX, posY) {
    if (spt === null || sheet === null) {
        return;
    }

    var hlf = {
        x: spt.cx,
        y: spt.cy
    };

    ctx.drawImage(sheet.img, spt.x, spt.y, spt.w, spt.h, posX + hlf.x, posY + hlf.y, spt.w, spt.h);
}
</code></pre>

<h3><a name=c4></a>Tiled</h3>

<p>Tiled is a general purpose tile map editor. It functions as a free tool to allow the easy creation of map layouts.<br/>
Here is a good site that I&rsquo;ve found that covers this topic pretty well: <a href="http://gamedevelopment.tutsplus.com/tutorials/introduction-to-tiled-map-editor--gamedev-2838">(Tiled Map Editor)</a></p>

<h3><a name=c5></a>Loading Map Data</h3>

<pre><code>var TILEDMapClass = Class.extend({

    fullyLoaded: false,

    load: function (map) {
    xhrGet(map, function(data) {
        this.fullyLoaded = true;
    });
    }
});

var gMap = new TILEDMapClass();

function xhrGet(reqUri,callback) {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", reqUri, true);
    xhr.onload = callback;

    xhr.send();
}
</code></pre>

<h3><a name=c6></a>Drawing Tiles</h3>

<p>Parsing tiles output, loading tileset data, tile packet and finally draw tiles on the screen.</p>

<pre><code>var TILEDMapClass = Class.extend({
    // This is where we store the full parsed
    // JSON of the map.json file.
    currMapData: null,

    // tilesets stores each individual tileset
    // from the map.json's 'tilesets' Array.
    // The structure of each entry of this
    // Array is explained below in the
    // parseAtlasDefinition method.
    tilesets: [],

    // This is where we store the width and
    // height of the map in tiles. This is
    // in the 'width' and 'height' fields
    // of map.json, respectively.
    // The values 100 here are just set
    // so these fields are initialized to
    // something, rather than null.
    numXTiles: 100,
    numYTiles: 100,

    // The size of each individual map
    // tile, in pixels. This is in the
    // 'tilewidth' and 'tileheight' fields
    // of map.json, respectively.
    // The values 64 here are just set
    // so these fields are initialized to
    // something, rather than null.
    tileSize: {
        "x": 64,
        "y": 64
    },

    // The size of the entire map,
    // in pixels. This is calculated
    // based on the 'numXTiles', 'numYTiles',
    // and 'tileSize' parameters.
    // The values 64 here are just set
    // so these fields are initialized to
    // something, rather than null.
    pixelSize: {
        "x": 64,
        "y": 64
    },

    // Counter to keep track of how many tile
    // images we have successfully loaded.
    imgLoadCount: 0,

    // Boolean flag we set once our tile images
    // has finished loading.
    fullyLoaded: false,

    //-----------------------------------------
    // Load the json file at the url 'map' into
    // memory. This is similar to the requests
    // we've done in the past using
    // XMLHttpRequests.
    load: function (map) {

        // Perform an XMLHttpRequest to grab the
        // JSON file at url 'map'.
        xhrGet(map, function (data) {
            // Once the XMLHttpRequest loads, call the
            // parseMapJSON method.
            gMap.parseMapJSON(data.responseText);
        });
    },

    //-----------------------------------------
    // Parses the map data from 'mapJSON', then
    // stores that data in a number of members
    // of our 'TILEDMapClass' that are defined
    // above.
    parseMapJSON: function (mapJSON) {
        // Call JSON.parse on 'mapJSON' and store
        // the resulting map data
        gMap.currMapData = JSON.parse(mapJSON);

        var map = gMap.currMapData;

        // Set 'numXTiles' and 'numYTiles' from the
        // 'width' and 'height' fields of our parsed
        // map data.
        gMap.numXTiles = map.width;
        gMap.numYTiles = map.height;

        // Set the 'tileSize.x' and 'tileSize.y' fields
        // from the 'tilewidth' and 'tileheight' fields
        // of our parsed map data.
        gMap.tileSize.x = map.tilewidth;
        gMap.tileSize.y = map.tileheight;

        // Set the 'pixelSize.x' and 'pixelSize.y' fields
        // by multiplying the number of tiles in our map
        // by the size of each tile in pixels.
        gMap.pixelSize.x = gMap.numXTiles * gMap.tileSize.x;
        gMap.pixelSize.y = gMap.numYTiles * gMap.tileSize.y;

        // Loop through 'map.tilesets', an Array...
        for(var i = 0; i &lt; map.tilesets.length; i++) {

            // ...loading each of the provided tilesets as
            // Images...
            var img = new Image();
            img.onload = function () {
                // ...Increment the above 'imgLoadCount'
                // field of 'TILEDMap' as each tileset is 
                // loading...
                gMap.imgLoadCount++;
                if (gMap.imgLoadCount === map.tilesets.length) {
                    // ...Once all the tilesets are loaded, 
                    // set the 'fullyLoaded' flag to true...
                    gMap.fullyLoaded = true;
                }
            };

            // The 'src' value to load each new Image from is in
            // the 'image' property of the 'tilesets'.
            img.src = map.tilesets[i].image;

            // This is the javascript object we'll create for
            // the 'tilesets' Array above. First, fill in the
            // given fields with the corresponding fields from
            // the 'tilesets' Array in 'currMapData'.
            var ts = {
                "firstgid": gMap.currMapData.tilesets[i].firstgid,

                // 'image' should equal the Image object we
                // just created.

                "image": img,
                "imageheight": gMap.currMapData.tilesets[i].imageheight,
                "imagewidth": gMap.currMapData.tilesets[i].imagewidth,
                "name": gMap.currMapData.tilesets[i].name,

                // These next two fields are tricky. You'll
                // need to calculate this data from the
                // width and height of the overall image and
                // the size of each individual tile.
                // 
                // Remember: This should be an integer, so you
                // might need to do a bit of manipulation after
                // you calculate it.

                "numXTiles": Math.floor(gMap.currMapData.tilesets[i].imagewidth / gMap.tileSize.x),
                "numYTiles": Math.floor(gMap.currMapData.tilesets[i].imageheight / gMap.tileSize.y)
            };

            // After that, push the newly created object into
            // the 'tilesets' Array above. Javascript Arrays
            // have a handy method called, appropriately, 'push'
            // that does exactly this. It takes the object
            // we'd like to put into the Array as a parameter.
            // 
            // YOUR CODE HERE
            gMap.tilesets.push(ts);
        }
    },

    //-----------------------------------------
    // Grabs a tile from our 'layer' data and returns
    // the 'pkt' object for the layer we want to draw.
    // It takes as a parameter 'tileIndex', which is
    // the id of the tile we'd like to draw in our
    // layer data.
    getTilePacket: function (tileIndex) {

        // We define a 'pkt' object that will contain
        // 
        // 1) The Image object of the given tile.
        // 2) The (x,y) values that we want to draw
        //    the tile to in map coordinates.
        var pkt = {
            "img": null,
            "px": 0,
            "py": 0
        };

        // The first thing we need to do is find the
        // appropriate tileset that we want to draw
        // from.
        //
        // Remember, if the tileset's 'firstgid'
        // parameter is less than the 'tileIndex'
        // of the tile we want to draw, then we know
        // that tile is not in the given tileset and
        // we can skip to the next one.
        var tile = 0;
        for(tile = gMap.tilesets.length - 1; tile &gt;= 0; tile--) {
            if(gMap.tilesets[tile].firstgid &lt;= tileIndex) break;
        }

        // Next, we need to set the 'img' parameter
        // in our 'pkt' object to the Image object
        // of the appropriate 'tileset' that we found
        // above.
        pkt.img = gMap.tilesets[tile].image;


        // Finally, we need to calculate the position to
        // draw to based on:
        //
        // 1) The local id of the tile, calculated from the
        //    'tileIndex' of the tile we want to draw and
        //    the 'firstgid' of the tileset we found earlier.
        var localIdx = tileIndex - gMap.tilesets[tile].firstgid;

        // 2) The (x,y) position of the tile in terms of the
        //    number of tiles in our tileset. This is based on
        //    the 'numXTiles' of the given tileset. Note that
        //    'numYTiles' isn't actually needed here. Think about
        //    how the tiles are arranged if you don't see this,
        //    It's a little tricky. You might want to use the 
        //    modulo and division operators here.
        var lTileX = Math.floor(localIdx % gMap.tilesets[tile].numXTiles);
        var lTileY = Math.floor(localIdx / gMap.tilesets[tile].numXTiles);

        // 3) the (x,y) pixel position in our tileset image of the
        //    tile we want to draw. This is based on the tile
        //    position we just calculated and the (x,y) size of
        //    each tile in pixels.
        pkt.px = (lTileX * gMap.tileSize.x);
        pkt.py = (lTileY * gMap.tileSize.y);


        return pkt;
    },

    //-----------------------------------------
    // Draws all of the map data to the passed-in
    // canvas context, 'ctx'.
    draw: function (ctx) {
        // First, we need to check if the map data has
        // already finished loading...
        if(!gMap.fullyLoaded) return;

        // ...Now, for every single layer in the 'layers' Array
        // of 'currMapData'...
        for(var layerIdx = 0; layerIdx &lt; gMap.currMapData.layers.length; layerIdx++) {
            // Check if the 'type' of the layer is "tilelayer". If it isn't, we don't
            // care about drawing it...
            if(gMap.currMapData.layers[layerIdx].type != "tilelayer") continue;

            // ...Grab the 'data' Array of the given layer...
            var dat = gMap.currMapData.layers[layerIdx].data;

            // ...For each tileID in the 'data' Array...
            for(var tileIDX = 0; tileIDX &lt; dat.length; tileIDX++) {
                // ...Check if that tileID is 0. Remember, we don't draw
                // draw those, so we can skip processing them...
                var tID = dat[tileIDX];
                if(tID === 0) continue;

                // ...If the tileID is not 0, then we grab the
                // packet data using getTilePacket.
                var tPKT = gMap.getTilePacket(tID);

                // Now we need to calculate the (x,y) position we want to draw
                // to in our game world.
                //
                // We've performed a similar calculation in 'getTilePacket',
                // think about how to calculate this based on the tile id and
                // various tile properties that our TILEDMapClass has.
                //
                // YOUR CODE HERE
                var dx = Math.floor(tileIDX % gMap.numXTiles) * gMap.tileSize.x;
                var dy = Math.floor(tileIDX / gMap.numXTiles) * gMap.tileSize.y;

                // Now, we're finally drawing the map to our canvas! The 'drawImage'
                // method of our 'ctx' object takes nine arguments:
                //
                // 1) The Image object to draw,
                // 2) The source x coordinate in our Image,
                // 3) The source y coordinate in our Image,
                // 4) The source width of our tile,
                // 5) The source height of our tile,
                // 6) The canvas x coordinate to draw to,
                // 7) The canvas y coordinate to draw to,
                // 8) The destination width,
                // 9) The destination height
                //
                // Note that we don't want to stretch our tiles at all, so the
                // source height and width should be the same as the destination!
                //
                // YOUR CODE HERE
                ctx.drawImage(tPKT.img, tPKT.px, tPKT.py, gMap.tileSize.x, gMap.tileSize.y, dx, dy, gMap.tileSize.x, gMap.tileSize.y);

            }
        }
    }

});

var gMap = new TILEDMapClass();
</code></pre>

<h3><a name=d0></a>Event Listening</h3>

<pre><code>function setup() {
    var canvas = document.getElementById('my_canvas');
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('keydown', onKeyDown);
}

function onMouseMove(event) {
    var posX = event.clientX;
    var posY = event.clientY;
    return posX;
}

function onKeyDown(event) {
    var keyID = event.keyID;
    return keyID;
}
</code></pre>

<h3><a name=d1></a>Keyboard Input Manager</h3>

<pre><code>InputEngineClass = Class.extend({

        keyState: new Array(256),

    //-----------------------------
    setup: function () {
        document.getElementById('my_canvas').addEventListener('mousemove', this.onMouseMove);
        document.getElementById('my_canvas').addEventListener('keydown', this.onKeyDown);
            document.getElementById('my_canvas').addEventListener('keyup', this.onKeyUp);   
    },

    //-----------------------------
    onMouseMove: function (event) {
        var posx = event.clientX;
        var posy = event.clientY;
    },

    //-----------------------------
    onKeyDown: function (event) {
            var keyID = event.keyID;
            this.keyState[keyID] = true;
    },

    //-----------------------------
    onKeyUp: function (event) {
        var keyID = event.keyID;
            this.keyState[keyID] = false;
    },

    //-----------------------------
    update: function() {
        KeyW = 87;

        if(this.keyState[KeyW])
            console.log("FORWARD!!!");
    }
});

gInputEngine = new InputEngineClass();
</code></pre>

<h3><a name=d2></a>Keymapped Input</h3>

<pre><code>InputEngineClass = Class.extend({

    bindings: {},

    actions: {},

    mouse: {
        x: 0,
        y: 0
    },

    //-----------------------------
    setup: function () {
        gInputEngine.bind(87, 'move-up');
        gInputEngine.bind(65, 'move-left');
        gInputEngine.bind(83, 'move-down');
        gInputEngine.bind(68, 'move-right');

        document.getElementById('my_canvas').addEventListener('mousemove', gInputEngine.onMouseMove);
        document.getElementById('my_canvas').addEventListener('keydown', gInputEngine.onKeyDown);
        document.getElementById('my_canvas').addEventListener('keyup', gInputEngine.onKeyUp);
    },

    //-----------------------------
    onMouseMove: function (event) {
        gInputEngine.mouse.x = event.clientX;
        gInputEngine.mouse.y = event.clientY;
    },

    //-----------------------------
    onKeyDown: function (event) {
        var action = this.bindings[event.keyID];

        if (action) {
            this.actions[action] = true;
        }
    },

    //-----------------------------
    onKeyUp: function (event) {
        var action = this.bindings[event.keyID];

        if (action) {
            this.actions[action] = false;
        }
    },

    bind: function (key, action) {
        this.bindings[key] = action;
    }

});

gInputEngine = new InputEngineClass();
</code></pre>

<h3><a name=d3></a>Physics Engine API</h3>

<pre><code>GameEngineClass = Class.extend({

    move_dir: new Vec2(0,0),
    dirVec: new Vec2(0,0),

    gPlayer0: {
        pos: {
            x: 100,
            y: 100
        },

        walkSpeed: 1,

        mpPhysBody: new BodyDef()
    },

    //-----------------------------
    setup: function () {
        gInputEngine.setup();
    },

    update: function () {
        if (gInputEngine.actions['move-up']) {
            gGameEngine.move_dir.y--;

        }
        if (gInputEngine.actions['move-down']) {
            gGameEngine.move_dir.y++;

        }
        if (gInputEngine.actions['move-left']) {
            gGameEngine.move_dir.x--;

        }
        if (gInputEngine.actions['move-right']) {
            gGameEngine.move_dir.x++;

        }

        if (gGameEngine.move_dir.LengthSquared()) {
            gGameEngine.move_dir.Normalize();
            gGameEngine.move_dir.Multiply(gGameEngine.gPlayer0.walkSpeed);
        }

        gGameEngine.gPlayer0.mpPhysBody.setLinearVelocity(gGameEngine.move_dir.x, gGameEngine.move_dir.y);

        if (gInputEngine.actions.fire0 || gInputEngine.actions.fire1) {
        }
    }
});

gGameEngine = new GameEngineClass();
</code></pre>

<h3><a name=d4></a>Mouse/Keyboard Firing</h3>

<pre><code>GameEngineClass = Class.extend({

    move_dir: new Vec2(0,0),
    dirVec: new Vec2(0,0),

    gPlayer0: {
        pos: {
            x: 100,
            y: 100
        },

        walkSpeed: 1,
        mpPhysBody: new BodyDef()
    },

    //-----------------------------
    setup: function () {
        gInputEngine.setup();
    },

    update: function () {
        if (gInputEngine.actions['move-up']) {
            gGameEngine.move_dir.y -= 1;
        }
        if (gInputEngine.actions['move-down']) {
            gGameEngine.move_dir.y += 1;
        }
        if (gInputEngine.actions['move-left']) {
            gGameEngine.move_dir.x -= 1;
        }
        if (gInputEngine.actions['move-right']) {
            gGameEngine.move_dir.x += 1;
        }

        if (gGameEngine.move_dir.LengthSquared()) {
            gGameEngine.move_dir.Normalize();
            gGameEngine.move_dir.Multiply(gGameEngine.gPlayer0.walkSpeed);
        }

        gGameEngine.gPlayer0.mpPhysBody.setLinearVelocity(gGameEngine.move_dir.x, gGameEngine.move_dir.y);

        if (gInputEngine.actions.fire0 || gInputEngine.actions.fire1) {
            var playerInScreenSpace = {
                x: gRenderEngine.getScreenPosition(this.gPlayer0.pos).x,
                y: gRenderEngine.getScreenPosition(this.gPlayer0.pos).y
            };

            dirVec.x = gInputEngine.mouse.x - playerInScreenSpace.x;
            dirVec.y = gInputEngine.mouse.y - playerInScreenSpace.y;

            dirVec.normalize();
        }

        if (gInputEngine.state('fire-up')) {
            gGameEngine.dirVec.y--;
        }
        else if (gInputEngine.state('fire-down')) {
            gGameEngine.dirVec.y++;
        }
        if (gInputEngine.state('fire-left')) {
            gGameEngine.dirVec.x--;
        }
        else if (gInputEngine.state('fire-right')) {
            gGameEngine.dirVec.x++;
        }
    }

});

gGameEngine = new GameEngineClass();
</code></pre>

<h3><a name=f0></a>AABB Collision</h3>

<pre><code>intersectRect: function (r1, r2) {
    return !(r2.left &gt; r1.right ||
        r2.right &lt; r1.left ||
        r2.top &gt; r1.bottom ||
        r2.bottom &lt; r1.top);
}
</code></pre>

<h3><a name=f1></a>Box2D</h3>

<pre><code>Vec2 = Box2D.Common.Math.b2Vec2;
BodyDef = Box2D.Dynamics.b2BodyDef;
Body = Box2D.Dynamics.b2Body;
FixtureDef = Box2D.Dynamics.b2FixtureDef;
Fixture = Box2D.Dynamics.b2Fixture;
World = Box2D.Dynamics.b2World;
MassData = Box2D.Collision.Shapes.b2MassData;
PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
CircleShape = Box2D.Collision.Shapes.b2CircleShape;
DebugDraw = Box2D.Dynamics.b2DebugDraw;
RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;

PhysicsEngineClass = Class.extend({
    world: null,

    PHYSICS_LOOP_HZ : 1.0 / 60.0,

    //-----------------------------------------
    create: function () {
        gPhysicsEngine.world = new World(
            new Vec2(0, 0), // Gravity vector
            false           // Don't allow sleep
        );
    },

    //-----------------------------------------
    update: function () {
        var start = Date.now();

        gPhysicsEngine.world.Step(
            gPhysicsEngine.PHYSICS_LOOP_HZ,    //frame-rate
            10,    //velocity iterations
            10     //position iterations
        );
        gPhysicsEngine.world.ClearForces();

        return(Date.now() - start);
    },

    //-----------------------------------------
    registerBody: function (bodyDef) {
        var body = gPhysicsEngine.world.CreateBody(bodyDef);
        return body;
    },

    //-----------------------------------------
    addBody: function (entityDef) {
        var bodyDef = new BodyDef();

        var BODY_STATES = {
            static: Body.b2_staticBody,
            dynamic: Body.b2_dynamicBody
        };

        bodyDef.type = BODY_STATES[entityDef.type];

        bodyDef.position.x = entityDef.x;
        bodyDef.position.y = entityDef.y;

        var body = gPhysicsEngine.registerBody(bodyDef);

        var fixtureDef = new FixtureDef();

        if(entityDef.useBouncyFixture) {
            this.fixtureDef.density = 1.0;
            this.fixtureDef.friction = 0;
            this.fixtureDef.restitution = 1.0;
        }

        var polygonShape = new PolygonShape();
        fixtureDef.shape = polygonShape;

        fixtureDef.shape.SetAsBox(entityDef.halfWidth, entityDef.halfHeight);

        body.CreateFixture(fixtureDef);

        return body;
    }

    //-----------------------------------------
    removeBody: function (obj) {
        gPhysicsEngine.world.DestroyBody(obj);
    }
});

var gPhysicsEngine = new PhysicsEngineClass();
</code></pre>

<h3><a name=g0></a>Sounds</h3>

<p><a href="http://www.goldwave.com/">GoldWave</a> allows to use unify your sounds.</p>

<h3><a name=h0></a>Batches</h3>

<pre><code>var gCachedAssets = {};

function loadAssets(assetList, callbackFcn) {
    var loadBatch = {
        count: 0,
        total: assetList.length,
        cb: callbackFcn
    };

    for(var i = 0; i &lt; assetList.length; i++) {
        if(gCachedAssets[assetList[i]] == null) {
            var assetType = getAssetTypeFromExtension(assetList[i]);

            if(assetType === 0) { // Asset is an image
                var img = new Image();
                img.onload = function () {
                    onLoadedCallback(img, loadBatch);
                };
                img.src = assetList[i];
                gCachedAssets[assetList[i]] = img;

            } else if(assetType === 1) { // Asset is Javascript
                var fileref = document.createElement('script');
                fileref.setAttribute("type", "text/javascript");
                fileref.onload = function (e){
                    onLoadedCallback(fileref,loadBatch);
                };
                fileref.setAttribute("src", assetList[i]);
                document.getElementsByTagName("head")[0].appendChild(fileref);
                gCachedAssets[assetList[i]] = fileref;
            }

        } else { // Asset is already loaded
            onLoadedCallback(gCachedAssets[assetList[i]], loadBatch);
        }
    }
}

function onLoadedCallback(asset, batch) {
    batch.count++;
    if(batch.count == batch.total) {
        batch.cb(asset);
    }
}

function getAssetTypeFromExtension(fname) {
    if(fname.indexOf('.jpg') != -1 || fname.indexOf('.jpeg') != -1 || fname.indexOf('.png') != -1 || fname.indexOf('.gif') != -1 || fname.indexOf('.wp') != -1) {
        // It's an image!
        return 0;
    }

    if(fname.indexOf('.js') != -1 || fname.indexOf('.json') != -1) {
        // It's javascript!
        return 1;
    }

    // Uh Oh
    return -1;
}
</code></pre>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Caroline Aubry</span></span>

      








  


<time datetime="2014-01-15T13:17:14+00:00" pubdate data-updated="true">Jan 15<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://caubry.github.io/udacity-html5-game-development/" data-via="" data-counturl="http://caubry.github.io/udacity-html5-game-development/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/extract-assets-from-a-swf-using-swfttools/" title="Previous Post: Extract assets from a SWF - Using swfttools">&laquo; Extract assets from a SWF - Using swfttools</a>
      
      
        <a class="basic-alignment right" href="/git-hooks-for-jshint-node-module-with-grunt/" title="Next Post: Git hooks for jshint node module with Grunt">Git hooks for jshint node module with Grunt &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    




  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Caroline Aubry -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
